## æ¡ä»¶ç±»å‹ä¸é«˜çº§ç±»å‹

æ¡ä»¶ç±»å‹çš„å®šä¹‰

> extends å…³é”®å­—ä¸ ä¸‰å…ƒè¡¨è¾¾å¼çš„ç»“åˆ
> å½“ extends å…³é”®å­—å·¦è¾¹çš„ç±»å‹å¯ä»¥==åˆ†é…==ç»™å³è¾¹çš„ç±»å‹æ—¶ï¼Œæˆ‘ä»¬å°†å¾—åˆ°è¡¨è¾¾å¼å·¦ä¾§çš„ç±»å‹(type in the first branch)ï¼Œå¦åˆ™æˆ‘ä»¬å°†å¾—åˆ°å³ä¾§çš„ç±»å‹(type in the latter branch)

```ts
someType extends OtherType ? TrueType : FalseType
```


### åˆ†é…

extends åœ¨ç±»å‹ä¸–ç•Œä¸­çš„ä¸€ä¸ªå¤§ç”¨é€”å°±æ˜¯åˆ¤æ–­ä¸€ä¸ªç±»å‹æ˜¯å¦å¯ä»¥åˆ†é…ç»™å¦ä¸€ä¸ªç±»å‹ï¼ˆè¿™ä¸ extends è¡¨ç¤ºç»§æ‰¿å…³å¿ƒæ˜¯æœ‰æ‰€åŒºåˆ«çš„)

ä¸¾ä¸€ä¸ªä¾‹å­

```ts
type duck = {
	name:string;
}

type cat = {
	name:string;
}

type resultType =  duck extends cat ? true ; fase; // true
```

æˆ‘ä»¬è¯´ cat æ˜¯å¯åˆ†é…ç»™ duck  çš„ï¼Œè¿™æ˜¯å› ä¸º duck ä¸ cat çš„ç±»å‹çº¦æŸå®Œå…¨ç›¸åŒ

```ts
type duck = {
	name:string;
	fly:() => void
}
type cat = {
	name:string;
}

type resultA = duck extends cat ? true : false; // true;

type resultB = cat extends duck ? true : false; // false;
```

ğŸ‘†åœ¨è¿™ä¸ªæ„ä¹‰ä¸Š  åˆ†é… ä¸ ç»§æ‰¿ æ˜¯æ¯”è¾ƒç›¸ä¼¼çš„

### åˆ†é…æ¡ä»¶ç±»å‹

>  å¯¹äºä½¿ç”¨ extends å…³é”®å­—çš„ æ¡ä»¶ç±»å‹(conditional types), å¦‚æœ extends å‰é¢çš„å‚æ•°æ˜¯ä¸€ä¸ª æ³›å‹ ,åªè¦æˆ‘ä»¬ä¼ å…¥ è”åˆç±»å‹ , å°±ä¼šè§¦å‘ typescript çš„ *åˆ†é…å¾‹*

åˆ†é…å¾‹

extends å‰çš„æ³›å‹(ä¼ å…¥çš„è”åˆç±»å‹) ä¼šè¢« **æ‹†åˆ†æˆå•é¡¹** , åˆ†åˆ«å¸¦å…¥ æ¡ä»¶ç±»å‹ , æœ€åå°†æ¯ä¸ªå•é¡¹çš„åˆ¤æ–­ç»“æœå†ç»„åˆæˆä¸€ä¸ª è”åˆç±»å‹ã€‚

é€šå¸¸æƒ…å†µä¸‹ union type vs other type

```ts
type resultA = "x" | "y" extends "x" ? true : false; // false; æ­¤å¤„çš„è”åˆç±»å‹è¢«è§†ä¸ºä¸€ä¸ªæ•´ä½“ä¸å­—é¢é‡ç±»å‹ "x" æ¯”è¾ƒ
```

æ³›å‹å‚æ•°ä¸‹ union type vs other type

```ts
type getType<T> = T extends "x" ? true : false;

type resultB = getType<"x" | "y"> // true | false
```

åœ¨ä¸Šä¾‹ä¸­ï¼Œunion ç±»å‹ `"x" | "y"` è¢«æ‹†è§£ä¸ºç±»å‹ `"x"` ä¸ `"y"` ä¸ ç±»å‹ `"x"` è¿›è¡Œæ¯”è¾ƒ

1. `"x" extends "x"` --> `true`
2. `"y" extends "x"` --> `false`
3. å¾—åˆ°ç»“æœ: `true | false`

### ç‰¹æ®Šçš„ never

```ts
// never æ˜¯ä»»ä½•ç±»å‹çš„å­ç±»å‹
type resultA = never extends "x" ? true : false; // true

type P<T> = T extends "x" ? true : false; 

type resultB<never> = T extends "x" ? string : number; // never
```

1. never æ˜¯ä»»ä½•ç±»å‹çš„å­ç±»å‹
2. åœ¨åˆ†é…æ¡ä»¶ç±»å‹ä¸­ï¼Œnever çœ‹ä½œäº†ä¸€ä¸ª**ç©ºçš„è”åˆç±»å‹**ï¼Œå³æ²¡æœ‰è”åˆé¡¹çš„è”åˆç±»å‹ã€‚<span class="imp">ä½†æ˜¯ç”±äºæ²¡æœ‰è”åˆé¡¹å¯ä»¥åˆ†é…ï¼Œè¡¨è¾¾å¼å¹¶æ²¡æœ‰è¢«æ‰§è¡Œï¼Œäºæ˜¯ `resultB` çš„ç»“æœä¸º `never` ï¼Œç±»ä¼¼äºæ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°</span>
 

### é˜²æ­¢æ¡ä»¶åˆ¤æ–­ä¸­çš„åˆ†é…

`[]`

ä½¿ç”¨ `[]` å°†æ³›å‹å‚æ•°æ‹¬èµ·æ¥ï¼Œä¾¿å¯ä»¥é˜»æ–­æ¡ä»¶åˆ¤æ–­ä¸­åˆ†é…

```ts
type P<T> = [T] extends otherType ? true : false;
```

### é«˜çº§ç±»å‹ä¸­çš„åº”ç”¨

#### Exclude

> `Exclude<unionTypeA, unionTypeB>`
> è¿”å›å€¼ï¼šåŒ…å« unionTypeA ç±»å‹é¡¹ åŒæ—¶ ä¸åŒ…å« unionTypeB ç±»å‹é¡¹ çš„ unionTypeC

***å®ç°ä¸€ä¸ª Exclude***

```ts
type MyExclude<T, U> = T extends U ? never : T;
```

#### Extract

> ä¸ exclude æ•ˆæœç›¸åï¼Œå°†å‚æ•°ä¸€ä¸­å«æœ‰å‚æ•°äºŒçš„é¡¹æå–å‡ºæ¥

```ts
type MyExtract<T, U> = T extends U ? T : never;
```

#### Pick

> è·å–ç±»å‹ä¸­çš„æŸä¸€é¡¹çš„ type

```ts
type MyPick<T, K extends keyof T> = {
	[P in K] : T[P]
} 
```


#### Awaited

> æ¥æ”¶ä¸€ä¸ª `Promise<type>` ç±»å‹
> è¿”å›å€¼ï¼štype ç±»å‹

***MyAwaited***

issues

1. åº”å½“é™åˆ¶ä¼ å…¥å€¼ä¸ºä¸€ä¸ª Promise
2. ä¼ å…¥å€¼ Promise æœ‰å¯èƒ½æœ‰åµŒå¥—

```ad-note
infer å¯ä»¥è§†ä¸ºä¸€ä¸ªå˜é‡ï¼Œ**åªèƒ½åœ¨æ¡ä»¶ç±»å‹é‡Œä½¿ç”¨** 

1. æ¨å¯¼ç±»å‹ä¸–ç•Œçš„å‚æ•°ç±»å‹ï¼šå¯ä»¥ç”¨äºæ¨å¯¼æ³›å‹å‚æ•°
2. JS ä¸–ç•Œï¼šè§£æ„æ¨å¯¼æ•°ç»„æˆå‘˜çš„ç±»å‹
```

- [ ] First of array â« ğŸ“… 2022-09-06


```ts
type MyAwait<T extends Promise<unknown>> =
	// æ¨å¯¼å–å€¼(ä¸»è¦åŠŸèƒ½ä¸ºå–å€¼, æ¡ä»¶åˆ†æ”¯å®é™…ä¸Šä½œåºŸ)
	T extends Promise<inter X>
		// å–å€¼æ˜¯å¦ä¸º Promise
		? X extends Promise<unknown>
			? MyAwait<X>; // æ˜¯ Promise é€’å½’
			:X // è¿”å›ç±»å‹
		: never // ä½œåºŸåˆ†æ”¯
```